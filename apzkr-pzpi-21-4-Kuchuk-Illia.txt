Міністерство освіти та науки України
Харківський національний університет радіоелектроніки


Факультет комп’ютерних наук


Кафедра програмної інженерії


КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи:  Програмна система тренувань кіберспортивних команд


Студент гр. ПЗПІ-21-4
	__________ Кучук І. А.
     (підпис)
	Керівник роботи
	__________  доц. Лещинська І. О.
     (підпис)
	

	Роботу захищено «__»_________2024 р.
з оцінкою _____________
	Комісія:
	__________ доц. Лещинська І. О.
     (підпис)
__________ доц. Лещинський І. О.
     (підпис)
__________ ст. викл. Сокорчук І. П.
     (підпис)
	



Харків  2024 р.


Харківський національний університет радіоелектроніки


Факультет комп’ютерних наук         Кафедра програмної інженерії                    
Спеціальність 121 – Інженерія програмного забезпечення        
Курс           3                 Семестр                                      6                                       
Навчальна дисципліна Архітектура програмного забезпечення        


ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТА


        Кучука Іллі Андрійовича                
1. Тема роботи: «Програмна система тренувань кіберспортивних команд »        
2. Термін узгодження завдання курсової роботи «24» березня 2024 р.
3. Термін здачі студентом закінченої роботи «26» серпня 2024 р.
4. Вихідні дані до проєкту (роботи): В програмній системі передбачити:
5. унікальність, можливість заробітку, актуальність, розповсюдженість, масштабованість, забезпечення конфіденційності та адміністрування системи, реалізація чотирьох компонентів (Back-end, Front-end, IoT)        
6. Зміст пояснювальної записки (перелік питань, що належить розробити) 
вступ, аналіз предметної області, постановка задачі, проєктування програмного проєкту, структура бази даних, розробка програмного проєкту, опис розробленої програмної системи, висновки, перелік посилань, додатки        
7. Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень) Deployment Diagram, Use Case Diagram, Entity-Relationship Model, Interaction Overview Diagram,  Activity Diagram, State Diagram, Component Diagram, Package Diagram        
________________
КАЛЕНДАРНИЙ ПЛАН






Номер
	Назва етапів курсової роботи
	Строк виконання етапів роботи
	Примітки
	1
	Функціональна специфікація
програмного проєкту
	04.04.24
	

	2
	Проєктування програмного
проєкту
	20.04.24
	

	3
	Кодування програмного проєкту
	20.05.24
	

	4
	Оформлення пояснювальної
записки
	31.05.24
	

	5
	Захист курсової роботи
	26.08.24
	

	

Дата видачі завдання «24» березня 2024 р.




Керівник
	__________  доц. Лещинська І. О.
     (підпис)
	

Завдання прийняв до виконання


ст. гр. ПЗПІ-21-4
	__________  Кучук І. А.
     (підпис)
	________________


РЕФЕРАТ




Пояснювальна записка до курсової роботи: 66 с., 17 рис., 3 додатки, 5 джерел. 
GOLANG, PYTHON, DJANGO, REST, АДМІНІСТРАТОР, ВІДВІДУВАЧІ, ГРА, ТРЕНУВАННЯ, ПРОГРАМНА СИСТЕМА, КІБЕРСПОРТ.
Об’єктом дослідження моєї курсової роботи є ринок кіберспорту, а саме створення системи для навчання та тренування кіберспортсменів аби перемагати на турнірах і бути конкурентоспроможними, створювати розклад тренувань та передивлятися показник серцебиття протягом гри. 
Метою курсової роботи є розробка системи, яка вирішуєш більшість проблем геймерів та тренерів, загалом підвищення якості надання послуг та посилення мотивації, і, як наслідок, перемог. 
Методи розробки базуються на технологіях монолітної архітектури з використанням мов програмування Golang, що забезпечує швидкість та стабільність вбудованої системи, та Python з великою кількістю веб інструментів. Системою управління базами даних було обрано PostgreSQL, клієнтська частина базується на TypeScript та бібліотеці Solid.js.
У результаті роботи здійснено програмну реалізацію системи тренувань кіберспортивних команд. Програмна система складається з вебзастосунка, сервера та смарт пристрою. 
________________


ЗМІСТ


ВСТУП        6
1. АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ        7
1.1 Загальний аналіз проблемної області        7
1.2 Бізнес-цілі та критерії успіху        8
1.3 Потреби клієнтів або ринку        9
1.4 Окреслення концепції        10
1.5 Головна функціональність        11
1.6 Припущення та залежності        12
1.7 Рамки первинного випуску        13
1.8 Рамки наступних випусків        14
1.9 Робоче середовище        15
2 ПОСТАНОВКА ЗАДАЧІ        16
3 ПРОЄКТУВАННЯ БАЗИ ДАНИХ        18
4 ТЕХНОЛОГІЇ ТА АРХІТЕКТУРНІ РІШЕННЯ        20
4.1 Архітектура серверної частини        20
4.2 Архітектура IoT частини        21
4.3 Архітектура клієнтської частини        24
5 ОПИС ПРОГРАМНОЇ СИСТЕМИ        28
5.1 Виклик і завантаження        28
5.2 Призначення та структура        29
5.3 Опис програмної реалізації        30
ВИСНОВКИ        36
Перелік джерел посилання        37
Додаток А Програмний код серверної частини        38
Додаток Б Програмний код IoT пристрою        48
Додаток В Програмний код клієнтської частини        56
________________


ВСТУП




У сучасному світі кіберспорт стає все більш популярним, залучаючи мільйони гравців та глядачів по всьому світу. Проте, як і в будь-якій іншій професійній діяльності, кіберспортсмени стикаються з численними викликами, які потребують ефективних рішень та нових підходів.
Конкуренція в кіберспорті, що зростає, вимагає від гравців постійного вдосконалення своїх навичок та підтримки високого рівня фізичної та психічної підготовки. Проте тренувальні процеси часто бувають недостатньо організованими та не завжди враховують індивідуальні потреби та цілі кожного гравця. Це може призвести до незадовільних результатів на змаганнях.
Розробка програмної системи, що дозволяє кіберспортсменам покращувати свої навички та фізичний стан через персоналізовані тренування, стане важливим кроком у напрямку професіоналізації цього виду спорту. Система дозволяє створювати індивідуальні розклади тренувань, відстежувати стан здоров'я гравців під час гри, а також надає можливості для оптимізації тренувальних процесів.
Головна мета цього проєкту полягає у розробці програмної системи для тренувань кіберспортсменів, яка сприятиме підвищенню ефективності тренувань та, як наслідок, допоможе досягати нових перемог на змаганнях.
________________
   1. АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1 Загальний аналіз проблемної області




Сфера кіберспорту швидко розвивається, і конкуренція що зростає вимагає від гравців постійного вдосконалення своїх навичок та підтримки високого рівня фізичної й ментальної підготовки. Однак наявні тренувальні системи та платформи часто не враховують індивідуальних потреб гравців, що призводить до зниження ефективності тренувань. Брак інтеграції з технологіями моніторингу здоров'я та відсутність персоналізованих рекомендацій також є суттєвими недоліками.
Гравці та їхні тренери часто натрапляють на труднощі у створенні ефективних тренувальних програм, які враховують як фізичні, так і психологічні аспекти підготовки. Відсутність доступу до оперативної інформації про стан здоров’я гравця під час гри може призвести до перевтоми, втрати концентрації й, як наслідок, до погіршення результатів на турнірах. Крім того, наявні рішення не завжди забезпечують необхідну гнучкість для швидкої адаптації тренувальних планів відповідно до змін у графіку або в стані гравця.
Для кіберспортсменів критично важливо мати доступ до системи, яка надає персоналізовані тренувальні програми, забезпечує моніторинг стану здоров'я у реальному часі та дозволяє тренерам оперативно реагувати на зміни. Це допоможе підвищити ефективність тренувань, зменшити ризики, пов’язані з перевтомою, і, зрештою, досягти кращих результатів у змаганнях.




1.2 Бізнес-цілі та критерії успіху




БЦ-1: Залучити тисячу активних користувачів протягом першого року після запуску системи.
        БЦ-2: Підвищити ефективність тренувань кіберспортсменів, щоб 80% користувачів зазначили про покращення своїх результатів на змаганнях через шість місяців.
        БЦ-3: Забезпечити стабільну роботу системи з мінімум 99% доступності протягом першого року використання.
        БЦ-4: Залучити десять відомих кіберспортивних команд до використання системи для своїх тренувань протягом одного року.
        БЦ-5: Розширити функціональність системи, додаючи нові можливості щокварталу для підтримки інтересу користувачів.
КУ-1: Забезпечити стабільну інтеграцію з різними смартпристроями для відстежування стану здоров’я гравців у реальному часі.
        КУ-2: Захистити персональні дані користувачів, використовуючи сучасні методи шифрування та інші протоколи безпеки.
        КУ-3: Проводити регулярні оновлення системи для збереження її актуальності та відповідності новим вимогам кіберспорту.
        КУ-4: Організувати партнерські угоди з п'ятьма кіберспортивними організаціями для просування системи протягом першого року.




1.3 Потреби клієнтів або ринку



У нашій системі існують два основних види користувачів: кіберспортсмени та тренери.
Потреби кіберспортсменів:
   * Підвищення ігрових навичок через регулярні тренування з персоналізованими рекомендаціями.
   * Відстежування показників здоров'я та продуктивності під час гри.
   * Доступ до тренувальних планів, що враховують індивідуальні потреби та цілі.
   * Підвищення мотивації через зручну аналітику та оцінку результатів.
   * Ефективна комунікація з тренерами та іншими членами команди.
Потреби тренерів:
   * Зручні інструменти для створення індивідуальних та командних тренувальних планів.
   * Можливість моніторингу фізичного та психологічного стану гравців під час тренувань.
   * Аналітичні дані для оцінки результативності тренувань і адаптації планів.
   * Підвищення продуктивності роботи завдяки автоматизації та інтеграції з іншими платформами.


1.4 Окреслення концепції




CybersportFabric – це інноваційна система для тренування кіберспортсменів, яка забезпечує індивідуалізовані тренувальні програми, моніторинг стану здоров'я гравців під час гри та аналітику, що допомагає покращувати їхні результати на змаганнях. Ми прагнемо стати провідною платформою для підготовки кіберспортсменів, забезпечуючи комплексний підхід до тренувань, що враховує фізичні, ментальні та тактичні аспекти.
CybersportFabric пропонує унікальний досвід тренування завдяки використанню передових технологій, таких як смартпристрої для моніторингу стану здоров’я у реальному часі та інтеграція з вебзастосунком для створення персоналізованих тренувальних планів. Система надає можливість як індивідуальним гравцям, так і цілим командам розробляти стратегії підготовки, адаптуючи їх до конкретних потреб і цілей.
Однією з ключових особливостей є можливість створення гнучких графіків тренувань, що дозволяє тренерам і гравцям оптимально використовувати свій час, а також отримувати оперативні рекомендації на основі аналізу ігрових даних та стану гравців. Також передбачена інтеграція з іншими платформами та пристроями, що робить систему зручною та універсальною у використанні.
CybersportFabric – це не просто тренувальна платформа, це комплексний інструмент для професійного розвитку кіберспортсменів, який допоможе їм досягти нових вершин у змаганнях та підтримувати високий рівень фізичної та психологічної підготовки.


1.5 Головна функціональність




ГФ-1: Реєстрація та профілі користувачів: Можливість реєстрації кіберспортсменів та тренерів, створення персональних профілів, де можна зберігати та керувати інформацією про тренування, досягнення та стан здоров'я.
ГФ-2: Індивідуальні та командні тренування: Система надає можливість створення та проведення як індивідуальних, так і командних тренувань, які включають тактичні, фізичні та ментальні аспекти підготовки.
ГФ-3: Моніторинг стану здоров'я в реальному часі: Інтеграція з різними смартпристроями для відстежування показників здоров'я гравців під час гри, таких як частота серцевих скорочень, рівень стресу та інші параметри, з можливістю отримання оперативних рекомендацій.
ГФ-4: Безпека даних: Забезпечення високого рівня безпеки та конфіденційності персональних даних користувачів за допомогою сучасних методів шифрування та протоколів безпеки.
ГФ-5: Аналіз та рекомендації на основі штучного інтелекту: Використання штучного інтелекту для аналізу ігрових даних, стану здоров'я та прогресу, що дозволяє надавати персоналізовані тренувальні програми та рекомендації.
ГФ-6: Спільнота та взаємодія: CybersportFabric забезпечує можливості для спілкування та взаємодії між користувачами, включаючи обмін досвідом, організацію командних заходів та спільних тренувань.
ГФ-7: Підтримка кількох мов: Забезпечення багатомовної підтримки для зручності користувачів з різних регіонів.


ГФ-8: Підтримка різних кіберспортивних дисциплін: Система підтримує широкий спектр кіберспортивних дисциплін, дозволяючи користувачам тренуватися в різних іграх, від стратегій до шутерів.
ГФ-9: Гнучкість налаштувань для команд та тренерів: Тренери та команди можуть налаштовувати систему відповідно до своїх потреб, додаючи власні тренувальні програми, графіки та інші налаштування.




1.6 Припущення та залежності




П-1: Користувачі, включаючи кіберспортсменів і тренерів, будуть готові платити за доступ до нашої системи та її розширених функцій.
П-2: Ми зможемо створити активну спільноту кіберспортсменів і тренерів, які будуть взаємодіяти, обмінюватися досвідом та мотивувати одне одного.
П-3: Ми зможемо налагодити партнерські стосунки з кіберспортивними командами, організаціями та постачальниками смартпристроїв для моніторингу здоров'я.
З-1: Від якості вебзастосунка, з яким будуть працювати користувачі, залежить їхній інтерес до системи та бажання придбати підписку.
З-2: Високий рівень безпеки даних підвищить довіру серед користувачів, зокрема кіберспортсменів та тренерів, до збереження їхніх особистих і тренувальних даних.




1.7 Рамки первинного випуску




Серверна (back-end) частина:
   * Реєстрація та авторизація користувачів: Забезпечення функціоналу для реєстрації нових користувачів та авторизації наявний. Система повинна підтримувати різні групи користувачів, тобто гравців та тренерів та відповідні права доступу.
   * Ігрові тренування: Створення та управління різноманітними ігровими тренуваннями.
   * Захист даних: Забезпечення безпеки особистих даних користувачів та інформації про їхні тренування.
   * Спільнота: Базова підтримка спільноти, включаючи можливість огляду профілів інших користувачів.
Smart пристрій частина:
   * Збір і відправлення даних: Smart пристрої повинні збирати дані про пульс користувача і відправляти ці дані на сервер.
Сайт (front-end) частина:
   * Реєстрація та вхід користувачів: Сторінки для реєстрації нових користувачів та входу в систему.
   * Панель керування: Для тренерів можливість керування тренуваннями та відвідувачами. 




1.8 Рамки наступних випусків




Серверна (back-end) частина:
   * аналітика та статистика: додаткові функції аналітики тренувань та надання звітів користувачам та адміністраторам;
   * відстеження прогресу: автоматичне відстеження фізичних показників користувачів, таких як спалені калорії та пройдена відстань;
   * відгуки про сервіс: можливість користувачам залишати відгуки про сервіс;
   * зберігання історії занять: збереження даних про всі проведені заняття;
   * просунутий штучний інтелект: професійніші алгоритми для надання рекомендацій тренувань.
Smart пристрій частина:
   * кількість датчиків: збільшити кількість показників, які збираються пристроєм.
Сайт (front-end) частина:
   * просунуте управління заняттями: гнучкі інструменти для управління розкладом, створення персональних посилань тощо;
   * перегляд аналітики та статистики: можливість перегляду аналітики та отримання звітів для користувачів і адміністраторів;
   * відгуки про сервіс: можливість залишення відгуків;
   * пошук і фільтрація: реалізація пошуку та фільтрації за різними критеріями.




1.9 Робоче середовище




Система буде направлена на людей з будь-якої країни. Користувачі матимуть постійний доступ до системи. Це буде досягнуто завдяки автономним серверам у тренувальних офісах. 
Також треба розширити зрозумілість застосунку завдяки локалізації. 
Для зберігання даних використовуватиметься PostgreSQL. Робота з СУБД здійснюватиметься за допомогою Django ORM.
Для розробки серверної частини буде використано Python DjangoRestFramework. Середовищем розробки буде Visual Studio Code. 
Середовищем розробки IoT частини буде Visual Studio Code, що використовує мову програмування Golang. Показники будуть симулюватися за допомогою випадкових чисел або підготовлених даних. 
Для розробки клієнтської частини буде використано фреймворк StartSolid на мові TypeScript. Середовищем розробки буде Visual Studio Code. 
________________


2 ПОСТАНОВКА ЗАДАЧІ
На основі проведеного аналізу предметної області, основною задачею проєкту є створення програмної системи для тренувань кіберспортсменів - CybersportFabric. Система повинна включати такі компоненти:
   * Інформація про користувачів, включаючи їхні ролі (гравці, тренери, адміністратори).
   * Дані про тренування, типи вправ та тренерів.
   * Інформація про IoT-пристрої, які використовуються для збору даних під час тренувань.
   * Реєстрація та вхід до системи.
   * Перегляд тренувань та вправ, можливість отримувати вправи від тренерів.
   * Комунікація з IoT-пристроєм для моніторингу фізичних показників під час тренувань.
   * Перегляд основної інформації про виконані тренування та отримані результати.
   * Підтримка різних мов, включаючи українську та англійську.
Детальніше розглянути потреби користувача можна на діаграмі прецедентів.
  

Рис. 2.1 – Діаграма прецедентів проєкту
________________
3 ПРОЄКТУВАННЯ БАЗИ ДАНИХ
        Для проєктування бази даних було розроблено ER-модель бази даних (див. рис 3.1). 
  

Рис. 3.1 – ER-модель бази даних
ER-модель бази даних для проєкту CybersportFabric складається з п'яти основних сутностей: Gamer, Trainer, Game, Training, і IoTInformation.
Опис зв'язків між сутностями:
   * Gamer та Trainer мають зв'язок один до одного, де кожен тренер є користувачем, а один користувач може бути тренером.
   * Trainer пов'язаний із сутністю Gamer через user_id — кожен тренер є користувачем системи.
   * Training пов'язана із сутностями Gamer і Trainer зв'язками один до багатьох, оскільки кожен тренер може проводити багато тренувань, а користувач може бути учасником багатьох тренувань.
   * Training та Game мають зв'язок один до одного, де кожне тренування пов'язане з однією грою.
   * IoTInformation пов'язана із сутністю Training зв'язком один до багатьох, оскільки під час одного тренування можуть бути зібрані дані від багатьох IoT пристроїв.
   * Gamer та IoTInformation мають зв'язок один до багатьох, оскільки один користувач може мати багато записів з інформацією від IoT пристроїв.
Додаткові зв'язки та деталі:
   * Усі сутності мають унікальні ідентифікатори (UUID) для забезпечення унікальності записів.
   * У сутності Training зберігається час початку і завершення тренування, а також зв'язок з грою та тренером.
   * IoTInformation містить дані, такі як частота серцевих скорочень та час запису, пов'язані з конкретним користувачем під час тренування.
        Ця модель даних забезпечує ефективне зберігання та управління інформацією про користувачів, їх ролі, тренування, ігри та дані IoT пристроїв у системі для тренування кіберспортсменів.










4 ТЕХНОЛОГІЇ ТА АРХІТЕКТУРНІ РІШЕННЯ
        4.1 Архітектура серверної частини




        Для написання серверної частини системи було обрано мову програмування Python з використанням фреймворку Django та розширенням до нього DjangoRestFramework. 
        Системою керування базами даних буде PostgreSQL, яка з серверної частини отримуватиме запити завдяки Django ORM.
        Для більш детальної візуалізації використаних технологій було розроблено діаграму розгортання (див. рис. 4.1). Для демонстрації можливостей сервера було обрано програне забезпечення HttpPie, що має можливість створювати та надсилати запити різних типів, встановлювати вміст запиту та його заголовки.
  

Рис. 4.1 – Діаграма розгортання для серверної частини системи “Sport Changer”




4.2 Архітектура IoT частини




IoT частина системи взаємодіятиме з одним класом користувачів, а саме з гравцями. Пристрій відправляє дані датчиків і в результаті виводить відповідь сервера на екран.
        Взаємодія користувача з IoT частиною системи представлено на діаграмі прецедентів (див. рис. 4.2).
  Рис. 4.2 – Діаграма прецедентів IoT частини системи “CybersportFabric”


Таким чином, діаграма прецедентів окреслює функціональні вимоги до IoT частини.
        Для демонстрації функціональних можливостей IoT частини системи, програмна реалізація виконана мовою програмування Golang, що максимально наближено до апаратних обмежень IoT пристрою.
Для друку інформації використовується консоль користувача. Надсилання даних реалізується за допомогою стандартної бібліотеки, самі дані надсилаються у JSON форматі.
Компіляція відбувається за допомогою go compiler.
Для більш детальної візуалізації взаємодії пристрою з користувачами системи було розроблено діаграму взаємодії (див. рис. 4.3).
  



Рис. 4.3 – Діаграма взаємодії для IoT частини системи “CybersportFabric”


Також було побудовано діаграму діяльності, що відображає взаємодію пристрою з backend частиною (див. рис. 4.4).
  

Рис. 4.4 – Діаграма діяльності для IoT частини системи “CybersportFabric”
Отже, завдяки діаграмам взаємодії та діяльності було визначено основні технології та архітектуру системи.




4.3 Архітектура клієнтської частини




Користувачами системи є 2 типи акторів: тренер та геймер. За допомогою клієнтської частини працівнику, клієнту надаються такі можливості, як авторизація та реєстрація, забезпечує відображення інформації відповідно ролі користувача, створення нових тренувань, їх відвідування, огляд інформації після тренування.
Для проєктування клієнтської частини попередньо була розроблена діаграма прецедентів (див. рис. 4.5).
  

Рис. 4.5 – Діаграма прецедентів проєкту


Для проєктування клієнтської частини попередньо була розроблена UML діаграму компонент (див. рис. 4.6). З неї видно, що основними файлами, які містять логіку та відповідають за відображення усієї необхідної інформації користувачеві, є entry-client.tsx та entry-server.tsx. Застосунок було розроблено відповідно до стандартів та правил розробки Solid застосунків. Окрім цього для забезпечення гарного досвіду користувача загалом використовувався асинхронним підхід розробки, що забезпечує не блокування застосунку на IO операціях. Фрагмент коду файлу entry-client.tsx та entry-server.tsx. наведено у додатку A.


  

Рис. 4.6 – UML діаграма компонента проєкт


Для структури програмної реалізації було виділено пакети, які її складають. Ці пакети та зв’язки між ними можна побачити на Діаграмі пакетів (рис. 4.7). Було виділено основний пакет рішення, який включає такі пакети, як Data, в якому зберігаються моделі та глобальний контекст. Presentation, який містить в собі обробку запитів користувача, комунікацію з сервером, зберігання даних під час роботи.
________________
  

Рис. 4.7 – UML діаграма пакетів проєкт


Для проєктування frontend частини також була розроблена UML діаграму станів (див. рис. 4.8). Початково користувач входить до системи, після чого має можливість продивитися та обрати тренування, продивитися інформацію про себе.
  

Рис. 4.8 – UML діаграма станів проєкт.
5 ОПИС ПРОГРАМНОЇ СИСТЕМИ
5.1 Виклик і завантаження




Для застосування програмної системи для треба розгорнути серверну частину та користувальницьку частину. Для цього треба завантажити останню версію python, зайти у каталог за допомогою консолі та ввести команду python3 -m pip install -r requirements.txt. Після чого python3 manage.py runserver 0.0.0.0:8000. Таким чином запуститься сервер. Далі треба завантажити середу запуску для frontend частини під назвою bun. Після чого у теці проєкту з frontend запустити bun run dev.
Після запуску програмний інтерфейс буде доступний за ip адресою комп’ютера або ж за localhost у разі запуску клієнтської частини локально. 
Для запуску IoT частини у консольному інтерфейсі можна завантажити потрібну скомпільовану версію або архів з початковим кодом та компілятор мови програмування golang з офіційного сайту, після чого в теці з проєктом прописати go build main.go http.go tokens.go user.go для створення виконувального файлу.




________________
5.2 Призначення та структура




Функції, які може виконувати програма, можна розбити на декілька модулів, а саме:
   * тренування;
   * тренери;
   * геймер;
   * авторизація та реєстрація;
   * показники тренувань.
        Модуль “Тренування” реалізовано операції створення та перегляду тренувань. 
        Модуль “Тренери” має в собі функціонал додаванням вправ відвідувачам, переглядом їх досягнень.
        Модуль “Геймер” надає можливість відвідувачам переглядати інформацію про себе, призначати собі IoT пристрої та доєднуватися до тренувань.
Модуль “Авторизація та реєстрація” надає функції для авторизації в систему та створення нового облікового запису, що дозволяє клієнту створити свій запис у базі даних та надалі входити у систему за допомогою своєї пошти та пароля. Для демонстрації можливостей системи, в системі наявні користувачі gamer та trainer.
        Модуль “Показники тренувань” дозволяє переглядати статистику за тренування.
5.3 Опис програмної реалізації




При відкритті веб сайту можна побачити сторінку головного екрана(див. рис. 5.1). 
  

Рис. 5.1 – Головний екран.
Також за допомогою кнопки вгорі з права можна перейти до авторизації (див. рис. 5.2).
  

Рис. 5.2 – Екран входу у систему.


Після входу в нас з'являється можливість продивитися наявні тренування, вийти з облікового запису та продивитися інформацію про себе (див. рис. 5.3).
  

Рис. 5.3 – Екран після входу.


Є також можливість приєднатися до тренування або продивитися статистику за вже минулі тренування (див. рис. 5.4).
  

Рис. 5.4 – Статистика за тренування


Також в сторінці про геймера є можливість продивитися історію ігор (див. рис. 5.5).
  
 
Рис. 5.5 – Статистика минулих тренувань.


Після входу як тренер з’являється можливість створювати нові тренування (див. рис. 5.6 та 5.7).


  

Рис. 5.6 – Кнопка створення нового тренування.
  

Рис. 5.7 – Форма створення нового тренування.


Як можна побачити, у формі наявні поля назви, опису часу початку та тривалості тренування.
________________
ВИСНОВКИ


За результатами виконання роботи було розроблено програмну систему тренувань кіберспортивних команд.
У процесі роботи було проаналізовано предметну область, спроєктовано базу даних, розроблено архітектуру серверної, IoT та клієнтської частин програмної системи та реалізовано її програмно за допомогою мов програмування Golang, Python, TypeScript.
Розроблена програмна система дозволяє користувачам переглядати заплановані тренування. Вона забезпечує реєстрацію та авторизацію користувачів, перегляд інформації про себе, свою статистику та історію тренувань. Система забезпечує моніторинг стану геймера під час тренування в реальному часті.
 




















 




Перелік джерел посилання
   1. Мартін Р. Чистий код: створення і рефакторинг за допомогою AGILE. – ФАБУЛА, 2019. – 416 с.
   2. Django. Django Project. URL: https://www.djangoproject.com/ (date of access: 23.08.2024).
   3. GitHub - dariubs/GoBooks: List of Golang books. GitHub. URL: https://github.com/dariubs/GoBooks (date of access: 23.08.2024).
   4. Home - Django REST framework. Home - Django REST framework. URL: https://www.django-rest-framework.org/ (date of access: 23.08.2024).
   5. Solid Docs. Solid Docs. URL: https://docs.solidjs.com/solid-start (date of access: 23.08.2024).
   6. Посилання на демонстрацію: https://youtu.be/2s_XdWdGYr0
________________
Додаток А Програмний код серверної частини
     1        from datetime import datetime
       
     2        from django.db import models
       
       
     3        class Gamer(models.Model):
     4            name = models.CharField(max_length=100)
     5            age = models.IntegerField()
       
     6            user = models.ForeignKey(
     7                "auth.User", on_delete=models.CASCADE, related_name="gamer"
     8            )
     9            games = models.ManyToManyField("Games")
    10            trainer = models.ForeignKey(
    11                "Trainer",
    12                on_delete=models.SET_NULL,
    13                null=True,
    14                default=None,
    15                related_name="gamers",
    16            )
       
       
    17        class Trainer(models.Model):
    18            name = models.CharField(max_length=100)
    19            age = models.IntegerField()
    20            average_skill = models.IntegerField(default=10)
       
    21            user = models.ForeignKey(
    22                "auth.User", on_delete=models.CASCADE, related_name="trainer"
    23            )
       
    24            games = models.ManyToManyField("Games")
       
       
    25        class Games(models.Model):
    26            name = models.CharField(max_length=100)
       
       
    27        class Training(models.Model):
    28            name = models.CharField(max_length=100)
    29            description = models.TextField()
    30            datetime = models.DateTimeField()
    31            duration = models.IntegerField()  # in secconds
    32            trainer = models.ForeignKey(Trainer, on_delete=models.CASCADE)
    33            gamers = models.ManyToManyField(Gamer)
       
       
    34        class IoTInformation(models.Model):
    35            gamer = models.ForeignKey(Gamer, on_delete=models.CASCADE, related_name="iot")
    36            training = models.ForeignKey(Training, on_delete=models.CASCADE, related_name="iot")
       
    37            heart_rate = models.IntegerField()
       
    38            datetime = models.DateTimeField(default=datetime.now)
    39        import random
    40        from datetime import datetime, timedelta
       
    41        import matplotlib
       
    42        matplotlib.use("Agg")
    43        import matplotlib.pyplot as plt
    44        from django.contrib.auth.models import User
    45        from rest_framework import generics, response, views, viewsets
    46        from rest_framework.response import Response
       
    47        from .models import Gamer, IoTInformation, Trainer, Training
    48        from .permisions import IsTrainerOrReadOnly
    49        from .serializers import (BaseUserSerializer, GamerSerializer, IdSerializer,
    50                                  IoTInformationUploadSerialization,
    51                                  TrainingSerializer)
       
       
    52        # Generics
    53        class IoTInformationListView(generics.ListAPIView):
    54            queryset = IoTInformation.objects.all()
    55            serializer_class = GamerSerializer
       
       
    56        # ModelViewSets
       
       
    57        class GamerViewSet(viewsets.ModelViewSet):
    58            queryset = Gamer.objects.all()
    59            serializer_class = GamerSerializer
       
       
    60        class GetMyTrainings(views.APIView):
    61            def get(self, request):
    62                gamer = Gamer.objects.get(user=request.user)
    63                if not gamer:
    64                    return Response({"message": "You are not a gamer"}, status=400)
    65                trainings = Training.objects.filter(gamers=gamer)
    66                return Response([i.id for i in trainings], status=200)
       
       
    67        class TrainingViewSet(viewsets.ModelViewSet):
    68            queryset = Training.objects.all()
    69            serializer_class = TrainingSerializer
    70            permission_classes = [IsTrainerOrReadOnly]
       
    71            def create(self, request):
    72                trainer = Trainer.objects.get(user=request.user)
    73                if not trainer:
    74                    return Response({"message": "You are not a trainer"}, status=400)
    75                request.data["trainer"] = trainer.id
    76                training_serializer = TrainingSerializer(data=request.data)
    77                if not training_serializer.is_valid():
    78                    return Response(training_serializer.errors, status=400)
    79                data = training_serializer.data
    80                training = Training.objects.create(
    81                    trainer=trainer,
    82                    duration=data["duration"],
    83                    datetime=data["datetime"],
    84                    description=data["description"],
    85                )
    86                training.save()
    87                return Response(TrainingSerializer(training).data, status=201)
       
    88            def get_queryset(self):
    89                return Training.objects.filter(datetime__gte=datetime.now())
       
       
    90        # APIViews
       
       
    91        class IsTrainer(views.APIView):
    92            def get(self, request):
    93                trainer = Trainer.objects.filter(user=request.user.id)
    94                print(trainer)
    95                if len(trainer) == 0:
    96                    return Response(
    97                        {"message": "You are not a trainer", "isTrainer": False}, status=400
    98                    )
    99                return Response({"message": "You are a trainer", "isTrainer": True}, status=200)
       
       
   100        class RegisterGamer(views.APIView):
   101            def post(self, request):
   102                user_serializer = BaseUserSerializer(data=request.data)
   103                if not user_serializer.is_valid():
   104                    return response.Response(user_serializer.errors, status=400)
   105                data = user_serializer.data
   106                user = User.objects.create_user(
   107                    username=data["email"],
   108                    email=data["email"],
   109                    password=data["password"],
   110                )
   111                gamer = Gamer.objects.create(
   112                    name=data["name"],
   113                    age=data["age"],
   114                    user=user,
   115                )
   116                gamer.save()
   117                return response.Response(GamerSerializer(gamer).data, status=201)
       
       
   118        class RegisterTrainer(views.APIView):
   119            def post(self, request):
   120                user_serializer = BaseUserSerializer(data=request.data)
   121                if not user_serializer.is_valid():
   122                    return response.Response(user_serializer.errors, status=400)
   123                data = user_serializer.data
   124                user = User.objects.create_user(
   125                    username=data["email"],
   126                    email=data["email"],
   127                    password=data["password"],
   128                )
   129                trainer = Trainer.objects.create(
   130                    name=data["name"],
   131                    age=data["age"],
   132                    user=user,
   133                )
   134                trainer.save()
   135                return response.Response(GamerSerializer(trainer).data, status=201)
       
       
   136        class AddGamerToTrain(views.APIView):
   137            def post(self, request, pk: int):
   138                id_serializer = IdSerializer(data=request.data)
   139                if id_serializer.is_valid():
   140                    id = id_serializer.data["id"]
   141                    gamer = Gamer.objects.get(pk=id)
   142                else:
   143                    user = request.user.id
   144                    gamer = Gamer.objects.get(user=user)
       
   145                training = Training.objects.get(pk=pk)
       
   146                training.gamers.add(gamer)
   147                training.save()
       
   148                return response.Response(TrainingSerializer(training).data, status=201)
       
       
   149        class GetStatisticFromSession(views.APIView):
   150            def get(self, request, pk: int):
   151                training = Training.objects.get(pk=pk)
   152                gamers = IoTInformation.objects.filter(training=training)
   153                return response.Response(
   154                    {"heard_rates": [i.heart_rate for i in gamers]}, status=200
   155                )
       
       
   156        class GetStatisticPlotFromSession(views.APIView):
   157            def get(self, request, pk: int):
   158                training = Training.objects.get(pk=pk)
   159                gamers = IoTInformation.objects.filter(training=training)
   160                heard_rates = [i.heart_rate for i in gamers]
   161                plt.plot(heard_rates)
   162                random_name = random.randint(0, 100000)
   163                with open(f"static/plot{random_name}.png", "wb") as temp:
   164                    plt.savefig(temp, format="png")
   165                return response.Response({"filename": f"plot{random_name}.png"}, status=200)
       
       
   166        class GetIoTData(views.APIView):
   167            def post(self, request, pk: int):
   168                iot_serializer = IoTInformationUploadSerialization(data=request.data)
   169                if not iot_serializer.is_valid():
   170                    return response.Response(iot_serializer.errors, status=400)
   171                training = Training.objects.get(pk=pk)
   172                gamer = Gamer.objects.get(user=request.user)
   173                iot = IoTInformation.objects.create(
   174                    gamer=gamer,
   175                    training=training,
   176                    heart_rate=iot_serializer.data["heart_rate"],
   177                )
   178                iot.save()
   179                return Response({"message": "All good"}, status=201)
       
       
   180        class GetCurrentTraining(views.APIView):
   181            def get(self, request):
   182                gamer = Gamer.objects.get(user=request.user)
   183                if not gamer:
   184                    return Response({"message": "You are not a gamer"}, status=400)
   185                trainings = Training.objects.filter(
   186                    gamers=gamer.id, datetime__gte=datetime.now()
   187                )
   188                for i in trainings:
   189                    print(i.datetime + timedelta(seconds=i.duration))
   190                    print(datetime.now() + timedelta(hours=3))
   191                trainings_list = [TrainingSerializer(i).data for i in trainings]
   192                print(trainings_list)
       
   193                return Response(trainings_list, status=200)
   194        from django.urls import path
       
   195        from .views import (AddGamerToTrain, GetCurrentTraining, GetIoTData,
   196                            GetMyTrainings, GetStatisticFromSession,
   197                            GetStatisticPlotFromSession, IsTrainer, RegisterGamer,
   198                            RegisterTrainer, TrainingViewSet)
       
   199        urlpatterns = [
   200            path(
   201                "trains/",
   202                TrainingViewSet.as_view({"get": "list", "post": "create"}),
   203                name="train",
   204            ),
   205            path("current_trains", GetCurrentTraining.as_view(), name="current_train"),
   206            path("trains/<int:pk>/add", AddGamerToTrain.as_view(), name="register_gamer"),
   207            path("trains/<int:pk>/end", GetStatisticFromSession.as_view(), name="iot"),
   208            path(
   209                "trains/<int:pk>/end/photo",
   210                GetStatisticPlotFromSession.as_view(),
   211                name="my_trainings",
   212            ),
   213            # path("me/<int:pk>", GetMe.as_view({"get": "retrieve"}), name="me"),
   214            path("me/is_trainer", IsTrainer.as_view(), name="is_trainer"),
   215            path("me/trainings", GetMyTrainings.as_view(), name="my_trainings"),
   216            path("trains/<int:pk>/iot", GetIoTData.as_view(), name="iot_data"),
   217            path("register/", RegisterGamer.as_view(), name="register_trainer"),
   218            path("trainer/register/", RegisterTrainer.as_view(), name="register"),
   219        ]
Додаток Б Програмний код IoT пристрою
     1        package main
       
     2        import (
     3                "fmt"
     4                "log"
     5                "sync"
     6                "time"
     7        )
       
     8        func GetAuthInfo(email, password *string) {
     9                fmt.Print("Input email: ")
    10                _, err := fmt.Scanln(email)
    11                if err != nil {
    12                        fmt.Println("Error: ", err)
    13                }
    14                fmt.Print("Input password: ")
    15                _, err = fmt.Scanln(password)
    16                if err != nil {
    17                        fmt.Println("Error: ", err)
    18                }
    19        }
       
    20        func GetAuthInfoPrepared(email, password *string) {
    21                log.Println("Use prepared data")
    22                *email = "s527@go.ua"
    23                *password = "hhee"
    24        }
       
    25        func main() {
    26                var email, password string
    27                // GetAuthInfoPrepared(&email, &password)
    28                GetAuthInfo(&email, &password)
       
    29                fmt.Println("Email: ", email)
    30                fmt.Println("Password: ", password)
       
    31                tokens := GetTokens(email, password)
    32                fmt.Println("Access token: ", tokens.AccessToken)
       
    33                var m sync.Mutex
    34                go func() {
    35                        for {
    36                                UpdateToken(&tokens, &m)
    37                                time.Sleep(time.Minute)
    38                                log.Println("Token updated")
    39                        }
    40                }()
       
    41                userInfo := UserInfo{60}
       
    42                for {
    43                        Id := GetCurrentTrains(&tokens, &m)
    44                        if Id == 0 {
    45                                fmt.Println("No trains")
    46                                time.Sleep(10 * time.Second)
    47                                continue
    48                        }
       
    49                        for range 10 {
    50                                fmt.Println("Current train id: ", Id)
       
    51                                SendIoTData(&userInfo, Id, &tokens, &m)
    52                                time.Sleep(time.Second)
    53                        }
    54                }
    55        }
    56        package main
       
    57        import (
    58                "bytes"
    59                "encoding/json"
    60                "fmt"
    61                "net/http"
    62                "strconv"
    63                "sync"
    64        )
       
    65        func GetTokens(email, password string) Tokens {
    66                jsonBody := []byte(`{"username": "` + email + `", "password": "` + password + `"}`)
    67                jsonReader := bytes.NewReader(jsonBody)
       
    68                resp, err := http.Post("http://localhost:8000/api/token/", "application/json", jsonReader)
    69                if err != nil {
    70                        fmt.Println("Error: ", err)
    71                }
       
    72                return TokensFromResp(resp)
    73        }
       
    74        func UpdateToken(tokens *Tokens, m *sync.Mutex) {
    75                m.Lock()
    76                defer m.Unlock()
       
    77                jsonBody := []byte(`{"refresh": "` + tokens.RefreshToken + `"}`)
    78                jsonReader := bytes.NewReader(jsonBody)
    79                resp, err := http.Post("http://localhost:8000/api/token/refresh/", "application/json", jsonReader)
    80                if err != nil {
    81                        fmt.Println("Error: ", err)
    82                }
       
    83                tokensFromResp := TokensFromResp(resp)
    84                tokens.AccessToken = tokensFromResp.AccessToken
    85                tokens.RefreshToken = tokensFromResp.RefreshToken
    86        }
       
    87        type Game struct {
    88                Id          int    `json:"id"`
    89                Name        string `json:"name"`
    90                Description string `json:"description"`
    91                Datetime    string `json:"datetime"`
    92                Duration    int    `json:"duration"`
    93                Trainer     int    `json:"trainer"`
    94        }
       
    95        func GetCurrentTrains(tokens *Tokens, m *sync.Mutex) int {
    96                req, err := http.NewRequest("GET", "http://localhost:8000/api/current_trains", nil)
    97                if err != nil {
    98                        fmt.Println("Error: ", err)
    99                }
       
   100                m.Lock()
   101                req.Header.Set("Authorization", "Bearer "+tokens.AccessToken)
   102                m.Unlock()
       
   103                client := &http.Client{}
   104                resp, err := client.Do(req)
   105                if err != nil {
   106                        fmt.Println("Error after request: ", err)
   107                }
       
   108                var games []Game
   109                err = json.NewDecoder(resp.Body).Decode(&games)
   110                if err != nil {
   111                        fmt.Println("Error in decode: ", err)
   112                        fmt.Println("Response: ", resp)
   113                }
   114                if len(games) == 0 {
   115                        fmt.Println("No games")
   116                        return 0
   117                }
       
   118                return games[0].Id
   119        }
       
   120        func SendIoTData(userInfo *UserInfo, trainId int, tokens *Tokens, m *sync.Mutex) {
   121                jsonBody := []byte(`{"heart_rate": ` + strconv.Itoa(userInfo.GetHeartRate()) + `}`)
   122                jsonReader := bytes.NewReader(jsonBody)
       
   123                m.Lock()
   124                req, err := http.NewRequest("POST", "http://localhost:8000/api/trains/"+strconv.Itoa(trainId)+"/iot", jsonReader)
   125                m.Unlock()
   126                if err != nil {
   127                        fmt.Println("Error: ", err)
   128                }
       
   129                fmt.Println("Tokens", tokens.AccessToken)
   130                req.Header.Set("Authorization", "Bearer "+tokens.AccessToken)
   131                req.Header.Set("Content-Type", "application/json")
       
   132                client := &http.Client{}
   133                resp, err := client.Do(req)
   134                if err != nil {
   135                        fmt.Println("Error after request: ", err)
   136                }
       
   137                fmt.Println("Response status: ", resp.Status)
   138        }
   139        package main
       
   140        import (
   141                "encoding/json"
   142                "log"
   143                "net/http"
   144        )
       
   145        type Tokens struct {
   146                AccessToken  string `json:"access"`
   147                RefreshToken string `json:"refresh"`
   148        }
       
   149        func TokensFromResp(resp *http.Response) Tokens {
   150                var tokens Tokens
   151                err := json.NewDecoder(resp.Body).Decode(&tokens)
   152                if err != nil {
   153                        log.Fatal(err)
   154                }
   155                return tokens
   156        }
   157        package main
       
   158        import (
   159                "math/rand"
   160        )
       
   161        type UserInfo struct {
   162                HeartRate int `json:'heart_rate'`
   163        }
       
   164        func (userInfo *UserInfo) GetHeartRate() int {
   165                userInfo.HeartRate += rand.Intn(3) - 1
   166                return userInfo.HeartRate
   167        }
Додаток В Програмний код клієнтської частини
     1        import { MetaProvider, Title } from "@solidjs/meta";
     2        import { Router } from "@solidjs/router";
     3        import { FileRoutes } from "@solidjs/start/router";
     4        import { Suspense } from "solid-js";
       
     5        import { Provider } from "./context";
       
     6        export default function App() {
     7          return (
     8            <Provider>
     9              <Router
    10                root={(props) => (
    11                  <MetaProvider>
    12                    <Title>SolidStart - Basic</Title>
    13                    <Suspense>{props.children}</Suspense>
    14                  </MetaProvider>
    15                )}
    16              >
    17                <FileRoutes />
    18              </Router>
    19            </Provider>
    20          );
    21        }
    22        import { createContext, Component, createSignal, useContext } from "solid-js";
    23        import { Tokens } from "./models";
       
    24        const AppContext = createContext();
       
    25        interface AppContextValue {
    26          children: any;
    27        }
       
    28        export const Provider: Component<AppContextValue> = (props) => {
    29          const [tokens, setTokens] = createSignal({
    30            access: "",
    31            refresh: "",
    32          } as Tokens);
    33          const deleteTokens = () => {
    34            setTokens({
    35              access: "",
    36              refresh: "",
    37            });
    38          };
    39          return (
    40            <AppContext.Provider value={[tokens, setTokens, deleteTokens]}>
    41              {props.children}
    42            </AppContext.Provider>
    43          );
    44        };
       
    45        export const useAppContext = () => useContext(AppContext);
    46        // @refresh reload
    47        import { mount, StartClient } from "@solidjs/start/client";
    48        import "./app.css";
       
    49        mount(() => <StartClient />, document.getElementById("app")!);
    50        // @refresh reload
    51        import { createHandler, StartServer } from "@solidjs/start/server";
    52        import "./app.css";
       
    53        export default createHandler(() => (
    54          <StartServer
    55            document={({ assets, children, scripts }) => (
    56              <html lang="en">
    57                <head>
    58                  <meta charset="utf-8" />
    59                  <meta name="viewport" content="width=device-width, initial-scale=1" />
    60                  <link rel="icon" href="/favicon.ico" />
    61                  {assets}
    62                </head>
    63                <body class="bg-red-50">
    64                  <div id="app">{children}</div>
    65                  {scripts}
    66                </body>
    67              </html>
    68            )}
    69          />
    70        ));
    71        import { Title } from "@solidjs/meta";
    72        import { createSignal, For, Show, createEffect } from "solid-js";
    73        import { redirect } from "@solidjs/router";
    74        import GameTile from "../components/GameTile";
    75        import Button from "../components/Button";
    76        import { GameModel } from "../models";
    77        import { useAppContext } from "../context";
       
    78        export default function Home() {
    79          const [games, setGames] = createSignal([] as GameModel[]);
    80          const [joined, setJoined] = createSignal([] as number[]);
    81          const [tokens, setTokens, deleteTokens] = useAppContext();
    82          const [isTrainer, setIsTrainer] = createSignal(false);
    83          setGames([
    84            {
    85              id: 1,
    86              name: "Game 1",
    87              description: "Game 1 description",
    88              datetime: "2021-09-01T12:00:00",
    89              duration: 60,
    90              trainerId: 1,
    91            },
    92          ]);
    93          createEffect(async () => {
    94            let resp = await fetch("http://localhost:8000/api/trains/", {
    95              method: "GET",
    96              headers: {
    97                "Content-Type": "application/json",
    98                Authorization: "Bearer " + tokens().access,
    99              },
   100            });
   101            if (resp.status == 200) {
   102              let data = await resp.json();
   103              console.log(data);
   104              setGames(data);
   105            }
       
   106            resp = await fetch("http://localhost:8000/api/me/trainings", {
   107              method: "GET",
   108              headers: {
   109                "Content-Type": "application/json",
   110                Authorization: "Bearer " + tokens().access,
   111              },
   112            });
   113            if (resp.status == 200) {
   114              let data = await resp.json();
   115              console.log(data);
   116              setJoined(data);
   117            }
   118            resp = await fetch("http://localhost:8000/api/me/is_trainer", {
   119              method: "GET",
   120              headers: {
   121                "Content-Type": "application/json",
   122                Authorization: "Bearer " + tokens().access,
   123              },
   124            });
   125            let data = await resp.json();
   126            console.log(data);
   127            setIsTrainer(data.isTrainer);
   128          }, 0);
       
   129          return (
   130            <>
   131              <header class="flex flex-row justify-between p-10">
   132                <h1 class="text-xl font-bold">
   133                  <a href="/">CyberSportmans Fabric</a>
   134                </h1>
   135                <ul>
   136                  <li class="flex flex-row gap-3">
   137                    <Show
   138                      when={tokens().access != ""}
   139                      fallback={
   140                        <a
   141                          href="/auth"
   142                          class="bg-primary text-white p-2 rounded-lg w-max self-center"
   143                        >
   144                          Auth
   145                        </a>
   146                      }
   147                    >
   148                      <a
   149                        href="/about"
   150                        class="bg-primary text-white p-2 rounded-lg w-max self-center"
   151                      >
   152                        About
   153                      </a>
   154                      <Button onClick={deleteTokens} text="Logout" />
   155                    </Show>
   156                  </li>
   157                </ul>
   158              </header>
   159              <main>
   160                <Title>Home</Title>
   161                <div class="flex flex-col gap-10">
   162                  <For each={games()}>
   163                    {(game) => (
   164                      <GameTile joined={joined().includes(game.id)} game={game} />
   165                    )}
   166                  </For>
   167                  <Show when={isTrainer()}>
   168                    <a href="/new-game" class="self-center">
   169                      <Button text="Make new train" onClick={() => {}} />
   170                    </a>
   171                  </Show>
   172                </div>
   173              </main>
   174            </>
   175          );
   176        }
   177        import { createSignal } from "solid-js";
   178        import { useAppContext } from "../context";
       
   179        const Home = () => {
   180          const [gameName, setGameName] = createSignal("");
   181          const [gameDescription, setGameDescription] = createSignal("");
   182          const [gameDatetime, setGameDatetime] = createSignal("");
   183          const [gameDuration, setGameDuration] = createSignal(0);
   184          const [tokens, setTokens] = useAppContext();
       
   185          const sendGame = async () => {
   186            let resp = await fetch("http://localhost:8000/api/trains/", {
   187              method: "POST",
   188              headers: {
   189                "Content-Type": "application/json",
   190                Authorization: "Bearer " + tokens().access,
   191              },
   192              body: JSON.stringify({
   193                name: gameName(),
   194                description: gameDescription(),
   195                datetime: gameDatetime(),
   196                duration: gameDuration(),
   197              }),
   198            });
   199            if (resp.status == 201) {
   200              console.log("Game created");
   201            }
   202          };
       
   203          return (
   204            <div class="w-full flex flex-col content-center p-5 gap-10">
   205              <div class="flex flex-row justify-between">
   206                <h1 class="text-xl font-bold">
   207                  <a href="/">CyberSportmans Fabric</a>
   208                </h1>
   209              </div>
   210              <form
   211                class="flex flex-col gap-5 w-min self-center"
   212                onSubmit={(e) => {
   213                  e.preventDefault();
   214                  sendGame();
   215                }}
   216              >
   217                <label>
   218                  Game name:
   219                  <input
   220                    type="text"
   221                    name="gameName"
   222                    class="p-1"
   223                    value={gameName()}
   224                    onChange={(e) => {
   225                      setGameName(e.target.value);
   226                      console.log(gameName());
   227                    }}
   228                  />
   229                </label>
   230                <label>
   231                  Game description:
   232                  <textarea
   233                    name="gameDescription"
   234                    class="p-1"
   235                    value={gameDescription()}
   236                    onChange={(e) => setGameDescription(e.target.value)}
   237                  />
   238                </label>
   239                <label>
   240                  Game datetime
   241                  <input
   242                    type="datetime-local"
   243                    name="gameDatetime"
   244                    class="p-1"
   245                    value={gameDatetime()}
   246                    onChange={(e) => setGameDatetime(e.target.value)}
   247                  />
   248                </label>
   249                <label>
   250                  Game duration (in minutes)
   251                  <input
   252                    type="number"
   253                    name="gameDuration"
   254                    class="p-1"
   255                    value={gameDuration()}
   256                    onChange={(e) => setGameDuration(parseInt(e.target.value))}
   257                  />
   258                </label>
       
   259                <button>Create</button>
   260              </form>
   261            </div>
   262          );
   263        };
       
   264        export default Home;
